use std::fs;
use clap::{ App, SubCommand, Arg };
use serde_json;
use crate::expect_pretty;
use crate::url_tree::{ self, UrlNode, ServerSettings, Config };

pub fn run_app() {
    let matches = App::new("Gemini Server")
        .version("0.1.0")
        .author("Sebastian Logemann <sllogemann1@gmail.com>")
        .about("A server that serves resources with the gemini protocol")
        .subcommand(SubCommand::with_name("start")
            .about("Starts the server")
        )
        .subcommand(SubCommand::with_name("init")
            .about("Creates a directory with a template for a server")
            .arg(Arg::with_name("path")
                .short("p")
                .long("path")
                .value_name("PATH")
                .takes_value(true)
                .help("Specifies the relative path in which to create the template directory, \
                if this is missing it will be created in the current directory")
            )
        )
        .subcommand(SubCommand::with_name("tree")
            .about("Writes a textual representation of the url tree generated by the server")
            .arg(Arg::with_name("out")
                .short("o")
                .long("out")
                .value_name("FILE")
                .takes_value(true)
                .help("Specifies the relative path to which the text should be written, \
                if this is missing, the text will be printed in the console")
            )
            .arg(Arg::with_name("domain")
                .short("d")
                .long("domain")
                .value_name("DOMAIN")
                .takes_value(true)
                .help("Specifies the domain for which the url tree should be represented, \
                if this is missing, the url trees for all domains will be written")
            )
        )
        .get_matches();

    if let Some(matches) = matches.subcommand_matches("tree") {
        let domain = matches.value_of("domain");
        let outfile = matches.value_of("out");

        write_tree(domain, outfile);
    }
    else if let Some(matches) = matches.subcommand_matches("init") {
        let path = matches.value_of("path").unwrap_or(".");
        
        create_template(path);
    }
    else if let Some(_) = matches.subcommand_matches("start") {
        crate::start_server();
    }
    else {
        crate::start_server();
    }
}

fn write_tree(domain: Option<&str>, outfile: Option<&str>) {
    let tree = url_tree::get_url_tree();
    let tree_display;
    if let Some(domain) = domain {
        let mut domain_node: Option<&UrlNode> = None;
        for node in &tree.roots {
            if node.name == domain {
                domain_node = Some(node);
            }
        }

        match domain_node {
            Some(node) => tree_display = format!("{}\n", node),
            None => {
                eprintln!("Error: The domain {} could not be found", domain);
                return;
            }
        }
    }
    else {
        let mut all_trees_display = String::new();
        for root in &tree.roots {
            all_trees_display += &format!("{}\n\n", root);
        }

        tree_display = all_trees_display;
    }

    match outfile {
        Some(path) => {
            fs::write(path, tree_display.as_bytes()).and_then(|_| Ok(())).unwrap();
            return;
        },
        None => eprintln!("{}", tree_display)
    }
}

fn create_template(path: &str) {
    let dir_fail = "Error: failed to create directory";

    // Create directories
    expect_pretty(fs::create_dir_all(format!("{}/root", path)), dir_fail);
    expect_pretty(fs::create_dir(format!("{}/temp", path)), dir_fail);
    expect_pretty(fs::create_dir(format!("{}/data", path)), dir_fail);
    expect_pretty(fs::create_dir(format!("{}/cgi", path)), dir_fail);

    // Create log file
    expect_pretty(fs::write(format!("{}/log.txt", path), "".as_bytes()), "Failed to create log file");

    // Create server settings
    let settings = ServerSettings {
        homepage: Some(String::from("index.gmi")),
        tls_profile: String::from("data/profile.pfx"),
        ..ServerSettings::default()
    };
    let settings_display = expect_pretty(serde_json::to_string_pretty(&settings), "Failed to serialize");
    expect_pretty(
        fs::write(
            format!("{}/server_settings.json", path), 
            settings_display.as_bytes()
        ),
        "Failed to create server_settings file"
    );

    // Create config file
    let config = Config {
        domain: None,
        whitelist: vec![String::from("index.gmi")],
        blacklist: Vec::new(),
        default_whitelist: false,
        dynamic: Vec::new(),
        link: Vec::new(),
        config_files: Vec::new(),
        default_preload: None
    };
    let config_display = expect_pretty(serde_json::to_string_pretty(&config), "Failed to serialize");
    expect_pretty(
        fs::write(
            format!("{}/root/config.json", path),
            config_display.as_bytes()
        ),
        "Failed to create config file"
    );

    // Create index.gmi
    let index_text = "\
        # Default Page\n\
        This is an example page.\n\
        * Example text\n\
        * More example text\n\
        => gemini://gemini.circumlunar.space/docs/specification.gmi Example link\n\
    ";
    expect_pretty(
        fs::write(
            format!("{}/root/index.gmi", path),
            index_text.as_bytes()
        ),
        "Failed to create config file"
    );

    // create .gitignore file
    let gitignore_text = "\
        # certificates // keys in the data dir\n\
        data/certificate.crt\n\
        data/private.key\n\
        data/profile.pfx\n\
        \n\
        # log\n\
        log.txt\n\
    ";
    expect_pretty(
        fs::write(
            format!("{}/.gitignore", path), 
            gitignore_text.as_bytes()
        ), 
        "Failed to create .gitignore file"
    );
}